# OPLL → OPL3 (2-operator) 再生方針と実装計画

## 概要
目的: OPLL(YM2413)のタイムライン（レジスタ書き込み列）から、OPL3(YMF262)のタイムラインを生成し、2オペのみで忠実かつ豪華に再生。

基本戦略:
- 周波数/ブロック(FNUM/BLK)、キーオン(KO)、EG(AR/DR/SL/RR)、KSR、TL/音量、FB、波形をOPL3へ対応づけ。
- リズムはOPL3リズムモードの割付に合わせ、OPLLのBD/SD/TOM/TC/HHをOPL3のBD/SD/TOM/TC/HHへマッピング。
- 豪華化の余地: パン（左右）、波形の選択（OPLL以外も許容）、一部チャンネルのレイヤー（同一2オペを別chへコピーしステレオ/デチューン）など、オプションとしてON/OFF。

## 実装プラン（フェーズ別）
### フェーズA（最小機能の忠実再生）
1) OPLL→OPL3マッパー（2オペ限定）をPythonで実装  
   - OPLLタイムラインCSV読込（既存loader_irを流用）  
   - OPL3レジスタ列への変換（CSV/VGM相当フォーマットで出力）
2) EG時間はまず「テーブル近似→OPL3レートへの写像」で時定数が大きく崩れないようにする  
   - 既存の ym2413_exact（OPLL側）と、OPL3のレートテーブル（近似）から、rate_mapを求める（初期は静的テーブル、後日フィッティング自動化）
3) リズムモードの基本対応（OPL3の0xBD制御、割当チャンネル/オペレータ初期化）
4) 波形は OPLL WF0→OPL3 wave0（sine）、WF1→OPL3 wave1（half-sine相当）を既定

### フェーズB（豪華化オプション）
5) パン制御（OPL3のパンレジスタで左右振り）  
6) レイヤリング（任意）：一部メロディchを別chへ複製（片側+数centデチューン/別波形）→“豪華さ”  
7) リズムの豪華化：各打楽器のTL/波形/FBなどを微調整プリセットで強化（YMFMを参考に固定パッチ集）

### フェーズC（精度向上）
8) ymfmやMAMEの定数からOPL3のEG時定数/レベル空間（TL/KSL/SL）の厳密値を抽出し、mappingを再校正  
9) スイープや検証（sweep.pyの--eg-model exact＋OPL3テーブル化）で、残留評価に感度が出ることを確認

## OPLL→OPL3 マッピング設計（2オペ限定）
- 周波数/ブロック(FNUM/BLK)  
  - OPLL: FNUMは低位8bitが0x10..0x18、高位は0x20..0x28内（BLKと同レジスタ）の上位ビット。  
  - OPL3: FNUM(10bit), BLK(3bit)。FNUMビット幅が異なる場合は「拡張（左シフト）→クリップ」で近似。IOIに対してピッチ誤差が聴感上支配しない範囲で合わせる。
- キーオン(KO)  
  - OPLL: 0x20..0x28 bit4。OPL3: 0xB0系のKEY-ONビットで代替。  
  - タイミングはできる限り忠実に（OPL3のEG立上がり特性差で微誤差は生じうる）
- EG(AR/DR/SL/RR), KSR  
  - OPLL: 4bitレート＋KSR(ON/OFF)。KSRはBLK依存の加算（ymfm相当は“blkに応じてrate加算”）。  
  - OPL3: レジスタ上のレートにKSRを加味（blkやfnum上位寄与）。まずは静的な rate_map（opll_rate→opl3_rate）を設け、KSRはON/OFFを合わせる。  
  - 後日、fitスクリプトで OPLLの実効時間（ym2413_exact）とOPL3の実効時間（テーブル）差を最小化するように rate_map を最適化。
- TL/音量/KSL/SL  
  - OPLL: 実質チャンネル音量＋モジュレータTL（6bit）＋KSL(2bit)。  
  - OPL3: 各オペにTLとKSL。基本は「キャリアTLをOPLLチャンネル音量に合わせて変換」、モジュレータTLは同等に移植。KSLはKSRと同様にON/OFF/強度を近似（初期は固定テーブル）。  
  - SLはレベル空間（dB系）で扱い、線形振幅へ変換（exactモード導入時に精密化）。
- FB/アルゴリズム  
  - OPLL: 固定接続（mod→car）＋FB（モジュレータ帰還）。  
  - OPL3: 同じく2オペのFBで再現。OPLLのFB値→OPL3のFB(0..7)へスケール。
- 波形  
  - 既定: OPLL WF0→OPL3 wave0（sine）、WF1→OPL3 wave1（half-sine相当）。  
  - オプションでOPL3の他波形（2/3/4...）を選択可（“豪華”モードで微変化）
- リズム  
  - OPLLとOPL2/3はいずれもCH6–8をベースに割当。ただし各ICでのオペレータ割付が異なる点に注意。  
  - OPL3リズムモード（0xBD）:  
    - BD: CH6の2オペ（mod+car）  
    - SD: CH7のキャリア  
    - TOM: CH8のキャリア  
    - TC: CH8のモジュレータ  
    - HH: CH7のモジュレータ  
  - OPLLのBD/SD/TOM/TC/HHに対し、上記OPL3割付へマップ。各打楽器のTL/SL/波形/FBはプリセットで近似→後日微調整。
- 豪華化  
  - パン: OPL3拡張で左右パン可能（ステレオ化）  
  - レイヤ: 同一2オペを別チャンネルで重ね、片方だけTL/波形/微デチューンする軽レイヤで“豪華さ”を演出（任意）

## 初期実装（Python）ファイル案
- OPLL CSV→OPL3 CSV 変換（最小セット）  
  - tools/opll2opl3/mapper.py: マッピングコア  
  - tools/opll2opl3/tables/opl3_mapping_ymfm.json: 初期マップ（AR/DR/RR, KSR, KSL/TLスケール, 波形, リズム割付）  
  - tools/opll2opl3/convert_opll_to_opl3.py: CLI（OPLL CSV→OPL3 CSV）  
  - tools/opll2opl3/README.md: 使い方とマッピングの考え方

  # OPLL → OPL3 変換プラン（更新版）

本ドキュメントは、OPLL→OPL3 変換におけるノートの KEYOFF タイミング（Gate）の決定方針と、その段階的実装計画をまとめたもの。現状の結論として、フェーズAの有効性と限界が見えてきたため、フェーズC（自動推定、特にYMFM連携）を優先的に掘り下げる。

更新履歴（今回の要点）
- フェーズA（gates.csv 指定）の有効性を確認
- 同時に、運用上/再現性の限界を認識
- オフライン変換でリアルタイム制約が無い前提で、フェーズCの優先度を上げる
- 当面は「gates.csv があれば使用、無ければ自動推定（将来）」の二段構えにする

---

## フェーズA: 事前推定（gates.csv）による固定ゲート適用

- 目的
  - 曲×チャンネルごとに最適な Gate を事前推定し、C実装に渡すことで「曲っぽさ」を大幅に改善。
- 仕様（C側）
  - CSVフォーマット: pattern, channel, gate, notes, score
  - 適用式: t_off = t_on + gate * (t_next_on - t_on)
  - パターン名はタイムラインCSVのベース名と一致させる
  - 環境変数 ESEOPL3_GATES_CSV でパス指定（無指定時は dist/gates.csv を探索）
  - 見つからない/一致しない場合のフォールバック: 既定値 gate=0.80
- 有効性（今回の検証サマリ）
  - 事前に用意した gates.csv を与えることで、指定なし（固定0.80一律）に比べ、フレージングや休符感が大幅に改善。
  - 「曲っぽさ」の回復に実用的に効く。
- 限界
  - 運用負荷: 曲ごとに事前計算が必要（スイープ、集計、ファイル管理）。
  - 静的: 演奏中に状況でゲートを変えることができない（チャンネル単位の代表値に固定）。
  - 最終ノート/特殊ケース: t_next_on が無い場合の取り扱いが固定的になりがち。
  - データ依存性: パターン名の一致や前処理パイプラインの整合に注意が必要。
- 位置づけ
  - 早期に品質を引き上げる暫定解としては極めて有効。
  - ただし最終形では「外部CSV不要で自動推定」へ移行したい。

備忘録（実装メモ）
- 既存Cコードは gates.csv を透過的に優先使用し、無い場合は既定値で動作。
- 将来の「自動推定（フェーズC）」導入時は優先度を「明示CSV > 自動推定 > 既定値」とする。

---

## フェーズB: 軽量ヒューリスティックによる自動推定（中間案）

- 目的
  - 外部CSVが無い場合でも、C内で短時間に「そこそこ妥当」な Gate をチャンネル単位で自動決定。
- 手法（概略）
  - 入力: ノートON時刻列（タイムライン）、簡易EG近似パラメータ（AR/DR/RR/SL/KSR、指数形状・SLカーブなど）。
  - 候補ゲート集合（例: 0.6, 0.7, 0.8, 0.9）をサーチ。
  - スコア関数: 
    - Overlapペナルティ（次ノートON時点の残響を抑える）
    - Gapペナルティ（無音期間が長すぎる場合を抑制）
    - 安定性（急激なゲート変化の抑制、初期は固定ゲートでOK）
  - 最良スコアの gate をチャンネル毎に採用。
- 長所/短所
  - 長所: 依存が少なく実装が早い。オフラインでも高速。
  - 短所: 近似なので厳密EG再現には限界。難曲での精度がYMFMに劣る可能性。

結論
- フェーズBは「CSV不要運用を早期に実現するブリッジ」として価値はあるが、最終的な再現度を重視するならフェーズCを優先着手したい。

---

## フェーズC: YMFM等の高忠実度EGシミュレーションによる自動推定（優先）

- 前提
  - 本プログラムはオフライン変換。リアルタイム制約なし。
  - YMFMのOPLL（YM2413）EG/コアを最小限取り込み、候補ゲートの評価を高精度に行う。
- 目標
  - 外部CSV不要。VGM（または派生タイムライン）からチャンネルごとの最適 Gate を自動抽出。
  - 将来的には「セクション/音価/テンポ」に応じた可変ゲート（局所最適）にも拡張可能。
- 入出力
  - 入力: VGMパース済みのタイムライン（ノートON/OFF、FNUM/BLK、KSR、パッチ推定情報）。
  - 出力: パターン×ch の Gate（まずは固定値/チャンネル代表値）、必要なら dist/gates_auto.csv にキャッシュ。
- アルゴリズム（第一段階：チャンネル固定ゲート）
  1) タイムライン構築（既存のOPLLラッパから取得）
  2) 候補ゲート集合を準備（例: 0.60〜0.95を等間隔、またはゴールデンセクション）
  3) YMFM EGシミュレーション
     - t_off 候補ごとに release をステップ更新し、t_next_on 時点の残響（相対振幅/エネルギ）を評価
     - KSR/BLK/SL/RRの反映、2オペ相互作用の簡易チェック（将来）
  4) スコアリング
     - Overlapペナルティ（残響閾値超過を減点）
     - Gapペナルティ（無音の過長を減点）
     - 正則化（過度に短い/長い Gate を抑制）
  5) 最高スコアの gate を採用
  6) キャッシュ（オプション）
- 実装計画（段階導入）
  - C1: YMFMの最小取り込み（EGのみ）＋チャンネル固定ゲート自動推定
    - 新規: src/opll/gate_auto_ymfm.{h,c}
    - 既存統合: src/opll/opll_to_opl3_wrapper.c から「gates.csv > 自動推定 > 既定値」の順で適用
    - CLI/環境:
      - --gate-auto=on/off（既定: CSV無ければon）
      - --gate-grid="0.6,0.7,0.8,0.9" or --gate-search=grid|golden
      - --gate-cache=dist/gates_auto.csv（任意）
      - --gate-metrics=logs/gate_metrics.csv（評価ログ）
  - C2: 評価の厳密化・高速化
    - バッチ並列（ch単位／候補ゲート単位）
    - しきい値/重みの自動調整
    - ペルカッションチャンネル別扱い
  - C3: 可変ゲート（セクション/音価別）
    - 長音と短音でゲートを局所最適化
    - 最低保持時間/リリース許容量のルール化
  - C4: 将来拡張
    - 2オペ音色マッピング最適化との同時最適化
    - 学習ベースの推定（任意）
- リスクと対策
  - 取り込みコスト: YMFMのベンダリングとビルド整備 → サブセット化/IF最小化で軽量化
  - 計算時間: オフライン前提。候補数×ノート数のスケール → 並列化とキャッシュで緩和
  - 再現性: EGテーブル/クロック/量子化の整合性を文書化し、テストで担保
- 受け入れ基準（サンプル曲での目安）
  - gates.csv（人手/事前推定）と同等以上の主観的な「曲っぽさ」
  - Overlap率/GAP率など客観メトリクスの改善
  - 同一入力に対する推定の決定性

---

## 優先順位と当面の方針

- 短期
  - 既存フェーズAを維持（gates.csv があれば優先使用）
  - ドキュメントとテストの整備（pattern名整合、フォールバック確認）
- 中期（優先）
  - フェーズCの C1 を実装（YMFM最小統合＋固定ゲート自動推定、キャッシュ対応）
  - CLI/ログ/計測系を整備してAB比較を容易化
- 長期
  - C2/C3で精度・柔軟性を拡張（可変ゲート、並列化、厳密スコア）
  - 2オペ音色マッピング最適化との連携

---

## 付録：今回の検証サマリ（メモ）

- gates.csv を指定しない場合（既定0.80一律）は「曲っぽさ」が不足
- gates.csv を適用すると、フレージング/休符感が改善し「十分曲らしく」再生された
- よって「曲×chで最適Gateは変わりうる」という仮説は支持される
- CSV運用の限界（準備コスト、静的、最終ノート処理など）が明確化
- オフライン変換でリアルタイム制約が無い前提では、YMFM連携の自動推定（フェーズC）が本筋

---

## 実装者向け備忘録

- 優先順位: 明示CSV > 自動推定 > 既定値（0.80）
- パターン名: タイムラインCSVのベース名と一致させる（不一致はフォールバック）
- 失敗時の挙動: CSV読み込み失敗/空欄/該当なし → 既定値で継続
- ログ: 自動推定時は採用ゲートとスコアをチャンネル毎に記録（将来の回帰テストに必須）
- テスト:
  - AB比較（既存 gates.csv vs 自動推定）
  - 既知難曲（オーバーラップ多発、テンポ可変など）での主観評価
- 次のPRに含めるべき最低限
  - YMFMサブセットの取り込みとラッパIF
  - gate_auto_ymfm.{h,c}（候補ゲート評価・選択）
  - ランタイム統合（wrapper内のフック点）
  - キャッシュ/ログのオプション（ベースライン生成のため）


  Copilot said: ありがとうございます。方針ドキュメントの更新も助かりますし、記録を残す大切さに共感します。ご要望の「主要FM音源エミュレータコアとライセンス」の一覧を用途とライセンス視点でまとめました。法的助言ではありませんが、実装判断の参考にしてください。 要点 - MITの本リポジトリに「そのまま同梱・静的リンク」して問題になりにくいのは、概ね「MIT/BSD系/Zlib」などの緩いライセンス。 - GPL系（MAME/DBOPL/Genesis Plus GXの多く）は、静的に取り込むとプロジェクト全体をGPL化する必要が出ます。避ける or 分離配布の慎重設計が必要。 -
ありがとうございます。方針ドキュメントの更新も助かりますし、記録を残す大切さに共感します。ご要望の「主要FM音源エミュレータコアとライセンス」の一覧を用途とライセンス視点でまとめました。法的助言ではありませんが、実装判断の参考にしてください。

## 既存エミュレータの積極的活用に関して、ライセンスの調査
要点

MITの本リポジトリに「そのまま同梱・静的リンク」して問題になりにくいのは、概ね「MIT/BSD系/Zlib」などの緩いライセンス。
GPL系（MAME/DBOPL/Genesis Plus GXの多く）は、静的に取り込むとプロジェクト全体をGPL化する必要が出ます。避ける or 分離配布の慎重設計が必要。
YMFMはBSD-3-Clauseで、OPL/OPN/OPM群を広くカバーするため、今回の「オフライン解析・自動推定の中核」に極めて相性が良いです。
Nuked系（OPL3/OPN2/OPM）はzlibで高精度・高負荷な実装が多く、特定チップの精度を上げたい場合の選択肢として優秀。
主要コア一覧（チップ別）

汎用（複数チップ）

YMFM (by Aaron Giles)
対応: YM2413/2203/2608/2610/2612/2151/3812/3526/8950/YMF262…など広範
言語: C++
ライセンス: BSD-3-Clause
備考: 現代的・保守的。今回のフェーズC（自動推定）基盤として最有力。MITと相性良し（著作権表示保持でOK）。
OPLL (YM2413)

emu2413 (Mitsutaka Okazaki)
言語: C
ライセンス: MIT
備考: 小型・取り込み容易。精度は十分実用、最新アルゴリズムや可搬性でYMFMに一歩譲る面も。
MAME ym2413
ライセンス: MAME全体は実質GPL-2.0+互換（個々ファイルは混在）。組み込みはGPL化リスク大。
OPL2/OPL3 (YM3812/YMF262)

Nuked-OPL3 (by Nuke.YKT)
言語: C
ライセンス: Zlib
備考: 事実上のリファレンス精度。重いがオフラインには好適。MITプロジェクトに組み込みやすい。
DBOPL (Dosbox OPL)
言語: C++
ライセンス: GPL-2.0+
備考: MIT直組み込みは不可（プロジェクトGPL化が必要）。
YMFM (上記)
備考: OPL3もカバー。単一フレームワークで他FMと一貫評価できる利点。
OPN (YM2612/2203/2608/2610)

Nuked-OPN2 (YM2612)
言語: C
ライセンス: Zlib
備考: 高精度で有名。Genesis系の再現性に定評。
YMFM
備考: YM2203/2608/2610/2612を包含。PC-98/NeoGeo系まで一気通貫に扱える。
fmgen（各種派生）
備考: 歴史的に多く使われていますが、派生でライセンス表記がまちまち（BSD系/独自/不明等）。利用時は個別のリポジトリで必ずLICENSEを要確認。
MAMEコア
ライセンス: 実質GPL-2.0+互換。MIT直取り込みは非推奨。
OPM (YM2151)

Nuked-OPM
言語: C
ライセンス: Zlib
備考: 高精度・負荷高め。X68000やArcadeの検証に。
YMFM
備考: OPMもサポート。
OPP (YM2164, FB-01)

YMFM
備考: OPP相当もカバー（移行容易）。単体実装もあるがライセンスばらつきのため個別確認推奨。
OPL4 (YMF278B)

MAMEコア
ライセンス: GPL系想定
備考: YMFMの対応状況は要確認。MITプロジェクトに静的取り込みは難あり。必要なら別バイナリ化など分離戦略。
ライセンス適合の実務的ガイド

MIT継続前提で「同梱/静的リンク」したい候補
YMFM（BSD-3-Clause）
Nuked-OPL3/OPN2/OPM（Zlib）
emu2413（MIT）
避ける/分離が必要な候補
MAME系（基本GPL-2.0+互換）/DBOPL/Genesis Plus GXなどGPLコア
同梱/静的リンクすればプロジェクト全体がGPL義務化
どうしても使う場合は「別プロセス実行」「ユーザーが別途入手したバイナリへIPC」「プラグインの動的ロード＋ユーザー責務」等で分離。ただしGPL適合は慎重な法的判断が必要
今回の目的（フェーズCに向けた方針）

第一候補: YMFMを中核に据える
理由: 広範囲チップ網羅・保守良好・BSD-3でMIT互換・解析/推定に必要なEG挙動を一貫して取得可能
変換品質のAB比較に、特定チップで Nuked 系（zlib）を併置して精度基準を取るのも有効（オプション/切替）
設計のコツ
依存のオプトイン化: USE_YMFM=1/USE_NUKED=1 などビルドフラグで切替
第三者ライブラリのNOTICE/著作権表記をdocs/THIRD_PARTY_NOTICES.mdに集約
将来MAME系を比較評価にだけ使う場合は、別ツール（外部）に分離して結果だけ取り込む運用が安全
参考（具体名とライセンスのひとこと）

YMFM: BSD-3-Clause
Nuked OPL3/OPN2/OPM: Zlib
emu2413: MIT
DBOPL (Dosbox): GPL-2.0+
MAME FM cores: 実質GPL-2.0+互換（混在だが全体としてGPL準拠が必要）
fmgen: フォークにより異なる（要リポジトリ確認）
